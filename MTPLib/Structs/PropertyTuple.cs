using Reloaded.Memory;
using Reloaded.Memory.Interfaces;
using Reloaded.Memory.Utilities;

namespace MTPLib.Structs
{
    public struct PropertyTuple : ICanReverseEndian
    {
        private short _a;
        private short _b;

        /// <summary>
        /// Represents the last entry of an array of property tuples.
        /// </summary>
        public static PropertyTuple Terminator => new PropertyTuple(0, -1);

        /// <summary>
        /// First component of the tuple.
        /// </summary>
        public short A
        {
            get => _a;
            set => _a = value;
        }

        /// <summary>
        /// Second component of the tuple.
        /// </summary>
        public short B
        {
            get => _b;
            set => _b = value;
        }

        public PropertyTuple(short a, short b)
        {
            _a = a;
            _b = b;
        }

        /* Generated by R# */
        public bool Equals(PropertyTuple other) => A == other.A && B == other.B;
        public override bool Equals(object obj) => obj is PropertyTuple other && Equals(other);
        public override int GetHashCode() => (A.GetHashCode() * 397) ^ B.GetHashCode();

        public void ReverseEndian()
        {
            _a = Endian.Reverse(_a);
            _b = Endian.Reverse(_b);
        }
    }
}