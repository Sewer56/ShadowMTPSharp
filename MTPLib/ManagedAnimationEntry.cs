using System.Collections.Generic;
using MTPLib.Structs;
using static MTPLib.Util.Equality;
using String = MTPLib.Util.String;

namespace MTPLib
{
    /// <summary>
    /// An individual file entry in the <see cref="MotionPackage"/> archive.
    /// </summary>
    public struct ManagedAnimationEntry
    {
        private byte[] _fileData;

        /// <summary>
        /// Contains the file name without extension.
        /// </summary>
        public string FileName { get; private set; }

        /// <summary>
        /// Contains the raw data of the file.
        /// </summary>
        public byte[] FileData => _fileData;

        /// <summary>
        /// Contains unknown properties. Not all animations have these.
        /// </summary>
        public PropertyTuple[] Tuples { get; private set; }

        public ManagedAnimationEntry(string fileName, byte[] fileData, PropertyTuple[] tuples)
        {
            FileName  = fileName;
            _fileData = fileData;
            Tuples    = tuples;
        }

        /// <summary>
        /// Creates a managed animation entry given a native entry.
        /// </summary>
        /// <param name="mtpFileAddress">Address of the first byte of the MTP file in memory.</param>
        /// <param name="entry">The native animation entry.</param>
        public static unsafe ManagedAnimationEntry FromAnimationEntry(byte* mtpFileAddress, AnimationEntry entry)
        {
            var managedAnimationEntry = new ManagedAnimationEntry();

            byte* fileNamePtr = entry.FileNamePtr + mtpFileAddress;
            byte* fileDataPtr = entry.FileDataPtr + mtpFileAddress;
            PropertyTuple* tuplePtr    = (PropertyTuple*) (entry.PropertyTuplePtr + mtpFileAddress);

            // Get File Name
            managedAnimationEntry.FileName = String.Win1252Encoder.GetString(fileNamePtr, String.Strlen(fileNamePtr));

            // Get File Data
            var header = MotionHeader.FromPointer(fileDataPtr);
            // Manual copy from unmanaged pointer into managed byte[]
            managedAnimationEntry._fileData = new byte[header.FileSize];
            for (int i = 0; i < header.FileSize; i++)
            {
                managedAnimationEntry._fileData[i] = fileDataPtr[i];
            }

            // Get File Tuples
            if (entry.HasProperties)
            {
                var tuples = new List<PropertyTuple>(32);
                PropertyTuple tuple;

                void AddTuple()
                {
                    tuple = *tuplePtr;
                    tuple.ReverseEndian();
                    tuples.Add(tuple);
                }

                while (!tuplePtr->Equals(PropertyTuple.Terminator))
                {
                    AddTuple();
                    tuplePtr++;
                }

                AddTuple();
                managedAnimationEntry.Tuples = tuples.ToArray();
            }

            return managedAnimationEntry;
        }

        public override string ToString()
        {
            return FileName;
        }

        /* Generated by R# */
        public bool Equals(ManagedAnimationEntry other) => string.Equals(FileName, other.FileName) && SequenceEqualWithNullSupport(FileData, other.FileData) && SequenceEqualWithNullSupport(Tuples, other.Tuples);
        public override bool Equals(object obj) => obj is ManagedAnimationEntry other && Equals(other);

        public override int GetHashCode()
        {
            var hashCode = (FileName != null ? FileName.GetHashCode() : 0);
            return hashCode;
        }
    }
}